# -*- coding: utf-8 -*-
"""project3_5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1At0be8zN3-iL3WfQvF-ikHXPxS9jRveW
"""

"""
Author: Jungmyung Lee

EMG–Motion Synchronization Pipeline (Single-Channel EMG + Marker Trajectory)
---------------------------------------------------------------------------
This script loads one EMG channel and one motion-capture marker (BAR_M)
from a MATLAB .mat file collected via Qualisys/QTM.

The workflow performs the following steps:

1) Load EMG + Motion Data
2) Process EMG signal through a biomechanics-standard pipeline:
      - DC offset removal
      - 100 Hz notch filtering
      - 20–450 Hz bandpass filtering
      - Full-wave rectification
      - RMS envelope extraction using a 50 ms window
3) Load barbell marker trajectory (Z-axis) for squat depth analysis
4) Synchronize EMG envelope and barbell trajectory using time vectors
5) Plot the EMG envelope alongside barbell movement over time

This visualization is commonly used for examining squat technique:
- EMG activation timing relative to barbell displacement
- Depth phases
- Left/right muscular compensation
"""

import scipy.io as sio
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import butter, filtfilt, iirnotch

# =========================
# Load MAT
# =========================
mat = sio.loadmat("/content/squat.mat")
root = mat['qtm_50_c2']

# =========================
# Load EMG (example: EMG 3 = analog[0,4])
# =========================
analog = root[0,0]['Analog']
emg = analog[0,4]

raw = emg['Data'][0]
fs = float(emg['Frequency'][0,0])

# Preprocess EMG (baseline → notch → bandpass → rect → envelope)
x = raw - np.mean(raw)

b_notch, a_notch = iirnotch(100/(fs/2), 30)
x = filtfilt(b_notch, a_notch, x)

def bp(low, high, fs, order=4):
    nyq = fs*0.5
    b, a = butter(order, [low/nyq, high/nyq], btype="band")
    return b, a

b_bp, a_bp = bp(20, 450, fs)
x_bp = filtfilt(b_bp, a_bp, x)

rect = np.abs(x_bp)

win = int(0.05 * fs)
window = np.ones(win) / win
env = np.sqrt(np.convolve(rect**2, window, mode="same"))

t_emg = np.arange(len(raw)) / fs   # EMG time vector



# =========================
# Load Bar Marker (BAR_M)
# =========================
traj = root[0,0]['Trajectories'][0,0]['Labeled'][0,0]

labels = traj['Labels'][0]     # (1,45) object array
data = traj['Data']            # (45, 4, 1890)
frame_rate = float(root[0,0]['FrameRate'][0,0])   # 100 Hz
frames = int(root[0,0]['Frames'][0,0])            # 1890

# Find BAR_M index
label_list = [str(l[0]) for l in labels]
bar_idx = label_list.index("BAR_M")

# Extract Z-axis of BAR_M
bar_z = data[bar_idx, 2, :]      # axis 2 = Z position
t_bar = np.arange(frames) / frame_rate   # motion capture time vector



# =========================
# Plot EMG Envelope + Bar Z-position
# =========================
plt.figure(figsize=(16,6))

plt.plot(t_bar, bar_z, color='black', linewidth=2, label="Bar (Z position)")
plt.plot(t_emg, env * 1000, color='orange', linewidth=1.5, label="EMG Envelope ×1000")

plt.title("Bar Z-axis vs EMG Envelope (Synchronized Time)", fontsize=16)
plt.xlabel("Time (s)", fontsize=14)
plt.ylabel("Position / EMG", fontsize=14)
plt.grid(True, alpha=0.3)
plt.legend()
plt.show()
