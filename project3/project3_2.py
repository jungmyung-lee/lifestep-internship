# -*- coding: utf-8 -*-
"""project3_2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gkLvtMth5jkDPgWSuD4oKn9ixFsxUw1u
"""

"""
Author: Jungmyung Lee

Interactive MATLAB Struct Browser
---------------------------------
A lightweight tool to explore deeply nested MATLAB .mat files used in
biomechanics and motion-capture research (e.g., EMG, marker trajectories,
force-plate data). MATLAB structs become numpy void/object arrays when
loaded in Python, making them difficult to inspect manually.

This browser:
  ‚Ä¢ Recursively navigates MATLAB structs
  ‚Ä¢ Displays nested fields and struct arrays as clickable buttons
  ‚Ä¢ Shows shapes and previews for large numeric arrays
  ‚Ä¢ Maintains navigation history for easy backtracking

Useful for inspecting QTM/Qualisys marker data, EMG analog channels,
and other hierarchical biomechanical datasets.
"""


import scipy.io as sio
import numpy as np
import ipywidgets as widgets
from IPython.display import display, clear_output

def make_button(text, on_click):
    btn = widgets.Button(description=text, layout=widgets.Layout(width='auto'))
    btn.on_click(on_click)
    return btn

class StructBrowser:
    def __init__(self, root_obj):
        self.stack = []
        self.current_obj = root_obj
        self.current_path = "root"
        self.output = widgets.Output()
        self.render()

    def render(self):
        with self.output:
            clear_output()
            print(f"üìÅ CURRENT PATH: {self.current_path}\n")

            obj = self.current_obj

            # ========== CASE 1: MATLAB struct (numpy void) ==========
            if isinstance(obj, np.void):
                fields = obj.dtype.names
                print("Fields:")

                btns = []
                for f in fields:
                    def handler(b, field=f):
                        self.enter(obj[field], field)
                    btns.append(make_button(text=f, on_click=handler))

                display(make_button("‚¨ÖÔ∏è BACK", lambda b: self.go_back()))
                display(widgets.VBox(btns))
                return


            # ========== CASE 2: numpy ndarray ==========
            elif isinstance(obj, np.ndarray):

                # --- Case 2A: it is actually a single struct (1x1 struct array)
                if obj.dtype.names and obj.shape == (1,1):
                    struct_obj = obj[0,0]
                    fields = struct_obj.dtype.names
                    print("Fields:")

                    btns = []
                    for f in fields:
                        def handler(b, field=f):
                            self.enter(struct_obj[field], field)
                        btns.append(make_button(text=f, on_click=handler))

                    display(make_button("‚¨ÖÔ∏è BACK", lambda b: self.go_back()))
                    display(widgets.VBox(btns))
                    return

                # --- Case 2B: struct array with many elements
                print(f"Array shape = {obj.shape}, dtype = {obj.dtype}\n")

                if obj.dtype.names or obj.dtype == object:
                    print("Elements:")
                    btns = []
                    for idx, _ in np.ndenumerate(obj):
                        def handler(b, index=idx):
                            self.enter(obj[index], f"[{index}]")
                        btns.append(make_button(text=str(idx), on_click=handler))

                    display(make_button("‚¨ÖÔ∏è BACK", lambda b: self.go_back()))
                    display(widgets.VBox(btns))
                    return

                # --- Case 2C: numeric array
                print("Numeric Array Preview:")
                preview = obj if obj.size < 50 else obj[:10]
                print(preview)
                display(make_button("‚¨ÖÔ∏è BACK", lambda b: self.go_back()))
                return


            # ========== CASE 3: primitive ==========
            else:
                print(f"Value: {obj}")
                display(make_button("‚¨ÖÔ∏è BACK", lambda b: self.go_back()))
                return

    def enter(self, new_obj, new_name):
        self.stack.append((self.current_obj, self.current_path))
        self.current_obj = new_obj
        self.current_path += f".{new_name}"
        self.render()

    def go_back(self):
        if not self.stack:
            return
        self.current_obj, self.current_path = self.stack.pop()
        self.render()

# Load MAT
mat = sio.loadmat("/content/squat.mat")
keys = [k for k in mat.keys() if not k.startswith("__")]
root = mat[keys[0]]

browser = StructBrowser(root)
browser.output