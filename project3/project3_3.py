# -*- coding: utf-8 -*-
"""project3_3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1l1PWrUvlMDjJPrure3RWT30vzROwetIJ
"""

"""
Author: Jungmyung Lee

This script loads the BAR_M Z-axis trajectory and five EMG channels,
then visualizes them in two synchronized sets of subplots: the full time
series and a manually selected time window.

Each EMG signal is processed using:
    rectification → window RMS → low-pass smoothing → peak normalization.

The output consists of 6 full-length plots + 6 sliced-window plots
(12 total), allowing direct comparison between barbell motion and
muscle activation patterns.
"""

import scipy.io as sio
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import butter, filtfilt, iirnotch

# =========================
# Load squat.mat
# =========================
mat = sio.loadmat("/content/squat.mat")
root = mat['qtm_50_c2']

analog = root[0,0]['Analog']
traj   = root[0,0]['Trajectories'][0,0]['Labeled'][0,0]

# 사용할 EMG index들
emg_indices = [3, 4, 5, 6, 8]

# =========================
# BAR_M Z trajectory
# =========================
labels     = traj['Labels'][0]
data       = traj['Data']
frame_rate = float(root[0,0]['FrameRate'][0,0])
frames     = int(root[0,0]['Frames'][0,0])

label_list = [str(l[0]) for l in labels]
bar_idx    = label_list.index("BAR_M")

# Z axis
bar_z = data[bar_idx, 2, :]
t_bar = np.arange(frames) / frame_rate

# =========================
# Filter definitions
# =========================
def lowpass(cut, fs, order=4):
    nyq = fs/2
    b, a = butter(order, cut/nyq, btype="low")
    return b, a

def bandpass(low, high, fs, order=4):
    nyq = fs/2
    b, a = butter(order, [low/nyq, high/nyq], btype="band")
    return b, a


# =========================
# Unified EMG preprocessing pipeline
# =========================
def preprocess_emg(raw, fs):
    """Rectification → Window RMS (50 ms) → LPF smoothing → Peak normalization"""

    # baseline removal
    x = raw - np.mean(raw)

    # notch
    b_notch, a_notch = iirnotch(100/(fs/2), 30)
    x = filtfilt(b_notch, a_notch, x)

    # bandpass
    b_bp, a_bp = bandpass(20, 450, fs)
    x_bp = filtfilt(b_bp, a_bp, x)

    # rectification
    rect = np.abs(x_bp)

    # RMS window (50ms)
    win = int(0.05 * fs)
    rms = np.sqrt(np.convolve(rect**2, np.ones(win)/win, mode="same"))

    # smoothing
    b_lp, a_lp = lowpass(6, fs)
    env = filtfilt(b_lp, a_lp, rms)

    # peak normalization
    env_norm = env / np.max(env)

    return rect, env_norm


# =========================
# PLOT — FULL RANGE
# =========================
n_rows = len(emg_indices) + 1
plt.figure(figsize=(15, 16))

# --- BAR_Z ---
ax0 = plt.subplot(n_rows, 1, 1)
ax0.plot(t_bar, bar_z)
ax0.set_ylabel("BAR Z")
ax0.grid(True)

ax0.set_xticks(np.arange(t_bar[0], t_bar[-1], 0.1), minor=True)
ax0.grid(True, which='minor', alpha=0.2)

# --- EMG FULL ---
for i, idx in enumerate(emg_indices):
    emg = analog[0, idx]
    raw = emg["Data"][0]
    fs  = float(emg["Frequency"][0,0])

    rect, env_norm = preprocess_emg(raw, fs)
    t_emg = np.arange(len(raw)) / fs

    ax = plt.subplot(n_rows, 1, i+2)
    ax.plot(t_emg, rect, alpha=0.4, label="Rectified")
    ax.plot(t_emg, env_norm, linewidth=1.2, label="Norm Envelope")

    ax.set_ylabel(f"EMG {idx}")
    ax.grid(True)

    ax.set_xticks(np.arange(t_emg[0], t_emg[-1], 0.1), minor=True)
    ax.grid(True, which='minor', alpha=0.2)

    if i == len(emg_indices)-1:
        ax.set_xlabel("Time (s)")

plt.tight_layout()
plt.show()


# =========================
# PLOT — SLICE (11.5~15.7 sec)
# =========================
slice_start = 11.5
slice_end   = 15.7

plt.figure(figsize=(15, 16))

# Bar Z slice
mask_bar = (t_bar >= slice_start) & (t_bar <= slice_end)
ax0 = plt.subplot(n_rows, 1, 1)
ax0.plot(t_bar[mask_bar], bar_z[mask_bar])
ax0.set_title("Sliced Window")
ax0.grid(True)
ax0.set_xticks(np.arange(slice_start, slice_end, 0.1), minor=True)

# EMG slice
for i, idx in enumerate(emg_indices):
    emg = analog[0, idx]
    raw = emg["Data"][0]
    fs  = float(emg["Frequency"][0,0])

    rect, env_norm = preprocess_emg(raw, fs)
    t_emg = np.arange(len(raw)) / fs

    mask = (t_emg >= slice_start) & (t_emg <= slice_end)

    ax = plt.subplot(n_rows, 1, i+2)
    ax.plot(t_emg[mask], rect[mask], alpha=0.4)
    ax.plot(t_emg[mask], env_norm[mask], linewidth=1.2)
    ax.grid(True)
    ax.set_ylabel(f"EMG {idx} (slice)")

    ax.set_xticks(np.arange(slice_start, slice_end, 0.1), minor=True)
    if i == len(emg_indices)-1:
        ax.set_xlabel("Time (s)")

plt.tight_layout()
plt.show()